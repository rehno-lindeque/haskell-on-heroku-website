<!doctype html>
<html class="no-transition add-section-toc"data-max-section-toc-level="1" lang="en">
<head>
<meta charset="utf-8">
<title>Haskell on Heroku — Documentation</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes,minimal-ui">
<base href="http://haskellonheroku.com/">
<link rel="canonical" href="http://haskellonheroku.com/documentation/">
<link rel="icon" type="image/png" href="_images/favicon-48.png" sizes="48x48">
<link rel="icon" type="image/png" href="_images/favicon-16.png" sizes="16x16">
<link rel="icon" type="image/png" href="_images/favicon-32.png" sizes="32x32">
<link rel="stylesheet" href="_stylesheets.css.gz">

<style>
  header a.link-documentation {
    color: #ac5cf0;
  }
</style>
</head>
<body>
<header id="top">
<div class="wrapper">
<nav id="header-menu-bar" class="menu-bar">
<h1 class="logotype"><a href="." title="Haskell on Heroku">Haskell on Heroku</a></h1>
<span id="header-button" class="menu-button"><a href="" title="Menu">Menu</a></span>
<ul id="header-menu" class="menu">
<li><a class="link-about" href="about/">About</a></li> <li><a class="link-documentation" href="documentation/">Documentation</a></li> <li><a href="https://github.com/mietek/haskell-on-heroku/">GitHub</a></li>
</ul>
<script>
if (localStorage['header-menu-open']) {
  document.getElementById('header-menu-bar').classList.add('open');
  document.getElementById('header-menu').classList.add('open');
  document.getElementById('header-button').classList.add('open');
}
</script>
</nav>


</div>
</header>

<main id="more">
<div class="wrapper">
<section id="documentation" class="level1">
<h1>Documentation</h1>
<p><em>Haskell on Heroku</em> user guide.</p>
<p>Detailed technical information is available in the <a href="documentation/reference/"><em>Haskell on Heroku</em> reference</a>.</p>
<p>Work in progress. Please report any problems with the documentation on the <a href="https://github.com/mietek/haskell-on-heroku-website/issues/"><em>haskell-on-heroku-website</em> issue tracker</a>.</p>
<blockquote>
<p>Contents:</p>
</blockquote>
<section id="packages" class="level2">
<h2>Packages</h2>
<p><em>Haskell on Heroku</em> is a buildpack for rapid deployment of Haskell web apps to Heroku, designed to be fast, efficient, and flexible.</p>
<p>Apps are expected to deploy in the time required to compile the pushed changes. There is no unnecessary recompiling or relinking. Only the minimum is stored in the Heroku cache. The resulting slugs are small, as they do not include the compilation environment—which can be restored in seconds, should the user wish to interact with the deployed app using GHCi.</p>
<p>All of this is made possible by using <a href="http://halcyon.sh/"><em>Halcyon</em></a> prebuilt packages.</p>
<section id="package-tiers" class="level3">
<h3>Package tiers</h3>
<p>Please be mindful of the many meanings of the term <em>package</em>. In this documentation, the term <em>package</em> always refers to one of the following four tiers of entities:</p>
<ol type="1">
<li><p><em>GHC packages</em>, which contain a live installation of GHC, archived to:<br /><code>halcyon-ghc-</code><em><code>ghcVersion</code></em><code>.tar.xz</code></p></li>
<li><p><em>Cabal packages</em>, in two flavours:</p>
<ul>
<li><p><em>Non-updated Cabal packages</em>, containing only the <code>cabal-install</code> executable and configuration file, archived to:<br /><code>halcyon-cabal-</code><em><code>cabalVersion</code></em><code>.tar.xz</code></p></li>
<li><p><em>Updated Cabal packages</em>, containing also an updated Cabal database, archived to:<br /><code>halcyon-cabal-</code><em><code>cabalVersion</code></em><code>-</code><em><code>updateTimestamp</code></em><code>.tar.xz</code></p></li>
</ul></li>
<li><p><em>Sandbox packages</em>, which contain a live sandbox, including all dependencies required to compile a specific app, archived to:<br /><code>halcyon-sandbox-</code><em><code>ghcVersion</code></em><code>-</code><em><code>appName</code></em><code>-</code><em><code>appVersion</code></em>-<em><code>sandboxDigest</code></em><code>.tar.gz</code></p></li>
<li><p><em>App packages</em>, which contain a live app executable, including all intermediate build products, archived to:<br /><code>halcyon-app-</code><em><code>ghcVersion</code></em><code>-</code><em><code>appName</code></em><code>-</code><em><code>appVersion</code></em><code>.tar.gz</code></p></li>
</ol>
<p>All packages include a <code>tag</code> file in their top-level directory, declaring the tier and contents of the package, the identifier of the targeted OS, and the root path of the installation.</p>
</section>
<section id="sandbox-packages" class="level3">
<h3>Sandbox packages</h3>
<p>Special consideration is due to sandbox packages. Every sandbox package includes a <code>cabal.config</code> file, which declares a set of constraints—the names and version numbers of all included dependencies. A <a href="http://en.wikipedia.org/wiki/SHA-1">SHA–1</a> digest of these constraints is embedded in the name of the package. This allows efficiently locating a sandbox which perfectly matches all required dependencies—by scanning a list of file names.</p>
<p>A copy of the <code>cabal.config</code> file is also kept next to the archived sandbox package:<br /><code>halcyon-sandbox-</code><em><code>ghcVersion</code></em><code>-</code><em><code>appName</code></em><code>-</code><em><code>appVersion</code></em>-<em><code>sandboxDigest</code></em><code>.cabal.config</code></p>
<p>If a perfectly matched sandbox cannot be located, each available configuration file is scanned and scored. Files including any extraneous constraints are ignored. The sandbox containing the best scoring set of constraints is selected as a base, copied, and extended with the missing packages. The resulting sandbox will match the required dependencies perfectly, without needing to be built from scratch.</p>
</section>
<section id="rationale" class="level3">
<h3>Rationale</h3>
<p>Separating the dependencies required to compile an app into four tiers is an attempt at striking a balance between the time spent compiling code, archiving compilation results, and transferring archives over the network.</p>
<p>The four-tiered design allows mixing-and-matching GHC and Cabal versions, updating the Cabal database incrementally or from scratch, and building new sandboxes based on existing sandboxes. This flexibility enables aiming for efficiency at every step—for example:</p>
<ul>
<li><p>The sandbox scoring process accepts only sandboxes which include a strict subset of the required dependencies. This ensures every sandbox built contains the minimum necessary amount of data.</p></li>
<li><p>As GHC packages are expected not to change often, they are archived using the slower LZMA algorithm, while the faster <span class="small-caps">Deflate</span> is used for app packages, which change on every deploy.</p></li>
</ul>
</section>
</section>
<section id="building-packages" class="level2">
<h2>Building packages</h2>
<p><em>Haskell on Heroku</em> is intended to be used with a private Amazon S3 bucket, defined by the <a href="documentation/reference/#halcyon_s3_bucket"><code>HALCYON_S3_BUCKET</code></a> configuration variable.</p>
<p>All packages required for compilation are downloaded from the private bucket. If a required package is not found while attempting to deploy an app, compilation will fail—but deployment will succeed! The deployed slug will contain only <em>Haskell on Heroku</em> itself. This approach, which may seem counter-intuitive, enables building the missing packages directly on Heroku, without the need to involve any external entities.</p>
<p>The user will be notified whenever compilation fails due to a missing package. The next step is building the missing packages on a one-off PX-sized dyno:</p>
<pre><code>$ heroku run --size=PX build</code></pre>
<p>The newly built packages will perfectly match all required dependencies, allowing subsequent compilation to succeed. Pushing an empty commit is the simplest way to deploy again:</p>
<pre><code>$ git commit --allow-empty --allow-empty-message -m &#39;&#39;
$ git push heroku master</code></pre>
<p>All built packages are archived and uploaded to the private S3 bucket, prefixed with an appropriate OS identifier. The original files used for the build are also uploaded to the private bucket, in order to decrease the overall load on upstream servers. All uploaded files are assigned an <a href="http://docs.aws.amazon.com/AmazonS3/latest/dev/S3_ACLs_UsingACLs.html">S3 ACL</a>, defined by <a href="documentation/reference/#halcyon_s3_acl"><code>HALCYON_S3_ACL</code></a>, which defaults to <code>private</code>.</p>
<p>Access to the private bucket is controlled by setting <a href="documentation/reference/#halcyon_aws_access_key"><code>HALCYON_AWS_ACCESS_KEY_ID</code></a> and <a href="documentation/reference/#halcyon_aws_secret_access_key"><code>HALCYON_AWS_SECRET_ACCESS_KEY</code></a>.</p>
<section id="public-packages" class="level3">
<h3>Public packages</h3>
<p>For the purposes of getting started quickly, it is also possible to use <a href="http://s3.halcyon.sh/">public packages</a>, by not defining a private bucket. This is not recommended for production usage, as the set of available public packages may change at any time.</p>
<p>Additionally, as public packages cannot match all dependencies required to compile every app, some apps will not compile successfully unless a private bucket is defined.</p>
<p>If a private bucket is defined, public packages are never used. This helps maintain complete control over the deployed code.</p>
</section>
<section id="rationale-1" class="level3">
<h3>Rationale</h3>
<p>A private bucket is necessary because of the separation between the dynos used for compiling apps and the one-off dynos used for building packages.</p>
<p>Compile dynos keep packages in the Heroku compile cache, but access ot the cache is not allowed from one-off dynos. Some form of external storage must be used to transfer the packages between dynos, and an Amazon S3 bucket is a good solution to this problem.</p>
<p>Building packages on-the-fly during deployment is not practical on Heroku, because apps are always compiled on 1X dynos, which offer 512MB RAM. This amount of memory is not sufficient to compile most Haskell web frameworks—indeed, compiling some of the more generously-proportioned frameworks requires in excess of 4GB RAM. Running out of memory will not stop deployment immediately—instead, the dyno will slowly grind to a halt, swapping data in and out of RAM, until the 15-minut Heroku compile time limit puts it out of its misery. Hence, building packages is best done on PX one-off dynos, which offer 6GB RAM, and where the time limit does not apply.</p>
<p>While <em>Haskell on Heroku</em> is designed to make building packages on one-off dynos as easy as possible, packages can also be built on any machine with an architecture and OS matching the specifications of the targeted Heroku stack—currently, Ubuntu 10.04 LTS or 14.04 LTS, both 64-bit. Please refer to the <a href="http://halcyon.sh/documentation/"><em>Halcyon</em> documentation</a> for details.</p>
<p>Storing packages externally also allows unrelated apps to share common dependencies. Sharing the same private bucket between multiple apps requires no additional configuration beyond defining the same private bucket for every app. This is the same method by which public packages are made available.</p>
</section>
<section id="special-considerations" class="level3">
<h3>Special considerations</h3>
<p>If the time required to compile the pushed changes is greater than the 15-minute Heroku compile time limit, it may be worth considering to split off part of the app into a library, allowing the library to be declared as a dependency and included in a sandbox package. As an interim measure, it is also possible to avoid compiling the app during deployment, by setting <a href="documentation/reference/#halcyon_dependencies_only"><code>HALCYON_DEPENDENCIES_ONLY</code></a> to <code>1</code>. This will allow building the app on a one-off dyno, as described above.</p>
</section>
</section>
<section id="caching-packages" class="level2">
<h2>Caching packages</h2>
<p><em>Haskell on Heroku</em> downloads all packages to the Heroku compile cache. The cache is automatically cleaned after every deployment, retaining only the most recently used packages.</p>
<p>Deleting the contents of the cache before deployment can be requested by setting the <a href="documentation/reference/#halcyon_purge_cache"><code>HALCYON_PURGE_CACHE</code></a> configuration variable to <code>1</code>. This is equivalent to using the <a href="https://github.com/heroku/heroku-repo#purge_cache"><code>purge_cache</code></a> command from the <a href="https://github.com/heroku/heroku-repo/"><code>heroku-repo</code></a> plugin, but more efficient. Please note the variable needs to be unset after use.</p>
<hr />
<p><em>To be continued…</em></p>
</section>
</section>
</div>
</main>
<footer id="bottom">
<div class="wrapper">
<nav id="footer-menu-bar" class="menu-bar">
<h1 class="logotype"><a href="." title="Haskell on Heroku">Haskell on Heroku</a></h1>
<span id="footer-button"><a href="#top" title="Top">Top</a></span>
<ul id="footer-menu" class="menu open">
<li><a class="link-about" href="about/">About</a></li> <li><a class="link-documentation" href="documentation/">Documentation</a></li> <li><a href="https://github.com/mietek/haskell-on-heroku/">GitHub</a></li>
</ul>
</nav>
<aside> <p> Made by <a href="http://mietek.io/">Miëtek Bak</a>. Supported by <a href="http://leastfixed.com/">Least Fixed</a>. Published under the <a href="license/">MIT X11 License</a>. Not affiliated with <a href="http://heroku.com/">Heroku</a>. </p> </aside>

</div>
</footer>
<!--[if lte IE 9]>
<div id="what-browser">
<div class="wrapper">
<aside>
<p>Please update your browser. “<a href="http://whatbrowser.org/" title="Find out!">What browser?</a>”</p>
</aside>
</div>
</div>
<![endif]-->
<script async src="_scripts.js.gz"></script>
</body>
</html>
